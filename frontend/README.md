# Agentic Frontend: Agentic UX & The "Glass Box" Interface

> [!NOTE]
> This is not a chatbot. This is a **Thinking Visualization Engine**.

## 1. UI/UX Philosophy

The standard "chat" interface is insufficient for Agentic AI. Users must trust the system, and trust comes from **transparency**.

### A. The "Glass Box" Concept

- **Show the Work**: We do not hide the "thought process." The UI visualizes the Active Agent, the Current Node, and the specific Step Log (Thought/Action/Result).
- **Artifacts over Messages**: While we support chat, the primary value is delivered through _Artifacts_ (Documents, Plans, Code) that generated by the agents.
- **Human-in-the-Loop (HITL)**: Control is paramount. The UI must clearly signal when the System is _Waiting_ for human approval (e.g., before executing a sensitive Tool).

### B. "Premium" as a Requirement

- **Aesthetics Function**: A disorganized UI leads to mistrust. We use high-contrast, modern typography (Inter), and subtle motion (Framer Motion) to convey system stability and intelligence.
- **Semantic Color**:
  - üîµ **Blue**: "Thinking" / Planning
  - üü¢ **Green**: Success / Safe Action
  - üü† **Orange**: Warning / HITL Required
  - üî¥ **Red**: Critical Failure / Rejection

## 2. Technical Architecture (Next.js App Router)

We adhere strictly to the **Server Components** model.

### A. Tech Stack

- **Framework**: Next.js 16.1 (App Router)
- **Library**: React 19 (RC)
- **Styling**: TailwindCSS 4 + Shadcn/UI (Radix Primitives)
- **Editor**: Monaco Editor (VSCode for the web)
- **Visualization**: React Flow + ElkJS (Auto-layout)

### B. Server Components vs. Client Islands

- **Default to Server**: Pages (`page.tsx`), Layouts (`layout.tsx`), and Data Fetching are Server Components.
- **Client Islands**: Only interactive elements (Forms, Real-time Graph Visualizers) use `'use client'`. This minimizes bundle size and ensures faster First Contentful Paint.

### C. Real-Time State Reflection (SSE)

- The UI is a direct reflection of the Backend's `GraphState`.
- We use **Server-Sent Events (SSE)** to stream updates. The frontend does not "guess" the state; it renders exactly what the Brain tells it.

## 3. Feature Showcase

### üß† Graph Visualizer (`GraphVisualizer.tsx`)

A real-time, auto-layout graph representing the agent's thought process.

- **Live Updates**: Nodes appear as the backend executes them.
- **State Inspection**: Click any node to see its Input, Thought, and Output.
- **Rerun Capability**: Fork execution from any point in the history.

### üïπÔ∏è Command Center (`CommandCenter.tsx`)

The central hub for user interaction.

- **Natural Language Input**: Chat with the agent.
- **Mode Switching**: Toggle between different agent personas.

### üìÇ File Explorer (`FileExplorer.tsx`)

Integrated workspace management.

- **View & Edit**: Check files created by the agent.
- **Syntax Highlighting**: Read code with extensive language support.

### üìü Terminal View (`TerminalView.tsx`)

Direct visibility into the agent's execution environment.

- **Process Logs**: See streaming stdout/stderr from tool execution.

## 4. Developer Guide

### Setup

```bash
# 1. Install dependencies
npm install

# 2. Run the development server
npm run dev
```

### Key Directories

- `src/components/brain/`: Components that visualize the graph (Nodes, Edges, Logs).
- `src/lib/api/`: Typed fetch wrappers for the FastAPI backend.
- `src/hooks/`: Custom hooks for SSE connection management (`useAgentStream`).

### Adding a New UI Feature

1. **Design First**: Does this increase clarity or just add noise?
2. **Componentize**: Create a reusable component in `src/components/ui`.
3. **Connect**: Use the global `AgentContext` or a specific hook to bind data.

---

**Critical Rule**: Never block the main thread. Agent updates can come in bursts; ensure the UI processes them efficiently without freezing.
